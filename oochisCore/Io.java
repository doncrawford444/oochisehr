/* * Copyright 2014 Donald Ray Crawford Jr. *  * This file is part of Oochis EHR. *  * Oochis EHR is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with Oochis EHR.  If not, see <http://www.gnu.org/licenses/>. */package oochisCore;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.print.PageFormat;import java.awt.print.Pageable;import java.awt.print.Printable;import java.awt.print.PrinterException;import java.awt.print.PrinterJob;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.EOFException;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Date;import java.util.Vector;import java.nio.channels.FileChannel;import javax.crypto.Cipher;import javax.crypto.CipherInputStream;import javax.crypto.CipherOutputStream;import javax.crypto.spec.SecretKeySpec;import javax.print.attribute.HashPrintRequestAttributeSet;import javax.print.attribute.PrintRequestAttributeSet;import javax.print.attribute.standard.Copies;import javax.print.attribute.standard.Sides;import javax.swing.JComponent;import javax.swing.JPanel;import javax.swing.RepaintManager;public class Io implements Printable, Pageable {	static Vector<JPanel> ppPrintPageJPanels;	static String ppOpenChartIDORUserName;	static String pPrintType;	public static byte[] rawTrumped = { 0x01, 0x00, 0x05, 0x06, 0x04, 0x05, 0x03, 0x0b, 0x08, 0x09, 0x0a, 0x07, 0x0c, 0x0f, 0x0e, 0x0d };	public static SecretKeySpec skeySpec;	public static SecretKeySpec skeySpec2;	public static byte[] rawTrumped2 = { 0x01, 0x00, 0x05, 0x06, 0x04, 0x05, 0x03, 0x0b, 0x08, 0x09, 0x0a, 0x07, 0x0c, 0x0f, 0x0e, 0x0d };	Io() {	}	public int print(Graphics graphics, PageFormat pPageFormat, int formNumber) {		SystemWindow.println("formNumber: " + formNumber);		if (formNumber < ppPrintPageJPanels.size()) {			Graphics2D graphics2D = (Graphics2D) graphics;			SystemWindow.println(" ");			SystemWindow.println("print accessed, formNumber = " + formNumber);			SystemWindow.println("print accessed, graphics = " + graphics);			SystemWindow.println("print accessed, pageFormat   = " + pPageFormat);			SystemWindow.println(" ");			graphics2D.translate(pPageFormat.getImageableX(), pPageFormat.getImageableY());			graphics2D.scale((pPageFormat.getImageableWidth()) / ppPrintPageJPanels.elementAt(formNumber).getWidth(), (pPageFormat.getImageableHeight() / ppPrintPageJPanels.elementAt(formNumber).getHeight()));			disableDoubleBuffering((JComponent) ppPrintPageJPanels.elementAt(formNumber));			ppPrintPageJPanels.elementAt(formNumber).paint(graphics2D);			enableDoubleBuffering((JComponent) ppPrintPageJPanels.elementAt(formNumber));			return (PAGE_EXISTS);		} else {			return (NO_SUCH_PAGE);		}	}	public static void disableDoubleBuffering(JComponent c) {		RepaintManager currentManager = RepaintManager.currentManager(c);		currentManager.setDoubleBufferingEnabled(false);	}	public static void enableDoubleBuffering(JComponent c) {		RepaintManager currentManager = RepaintManager.currentManager(c);		currentManager.setDoubleBufferingEnabled(true);	}	@Override	public int getNumberOfPages() {		throw new UnsupportedOperationException("Not supported yet.");	}	@Override	public PageFormat getPageFormat(int pageIndex) throws IndexOutOfBoundsException {		throw new UnsupportedOperationException("Not supported yet.");	}	@Override	public Printable getPrintable(int pageIndex) throws IndexOutOfBoundsException {		throw new UnsupportedOperationException("Not supported yet.");	}	public void printNow(String pOpenChartIDORUserName, String printType, Vector<JPanel> pPrintPageJPanels) {		pPrintType = printType;		ppOpenChartIDORUserName = pOpenChartIDORUserName;		ppPrintPageJPanels = pPrintPageJPanels;		PrinterJob job = null;		PrintRequestAttributeSet aset;		aset = new HashPrintRequestAttributeSet();		aset.add(new Copies(1));		aset.add(Sides.ONE_SIDED);		job = PrinterJob.getPrinterJob();		job.setPrintable(this);		if (pPrintType.equals("CHART")) {			job.setJobName("Chart " + pOpenChartIDORUserName + " - Vitality� EHR");		} else if (pPrintType.equals("REPORT")) {			job.setJobName("Report " + pOpenChartIDORUserName + " - Vitality� EHR");		}		try {			job.print();		} catch (PrinterException e) {			e.printStackTrace();		}	}	public static void biomoietyDictionary(String codeSet) throws Exception {		Vector<Vector<String>> codeSetVector = new Vector<Vector<String>>();		BufferedReader inputStream;		String lineString;		String eOF = "EOFdNk.ya8c5d";		String deliminator = "\t";		int rightDeliminatorIndice;		int leftDeliminatorIndice;		String lineStartDeliminator = "<----Clip Here for Data----->";		boolean stopReadingLinetokens = false;		String deliminatedToken;		if (codeSet.equals("HUGO")) {			inputStream = new BufferedReader(new FileReader(Device.binDir + "Medical_code_sets/HUGO.dat"));			while (!stopReadingLinetokens && !(lineString = inputStream.readLine()).equals(eOF)) {				if (lineString.equals(lineStartDeliminator)) {					lineString = inputStream.readLine();					stopReadingLinetokens = true;				}			}			try {				while (!(lineString = inputStream.readLine()).equals(eOF)) {					codeSetVector.add(new Vector<String>());					rightDeliminatorIndice = lineString.indexOf(deliminator);					leftDeliminatorIndice = 0;					stopReadingLinetokens = false;					while (!stopReadingLinetokens) {						if (rightDeliminatorIndice == -1) {							stopReadingLinetokens = true;							deliminatedToken = lineString.substring(leftDeliminatorIndice);							deliminatedToken = deliminatedToken.trim();						} else if (leftDeliminatorIndice == rightDeliminatorIndice) {							deliminatedToken = "";						} else {							deliminatedToken = lineString.substring(leftDeliminatorIndice, rightDeliminatorIndice);							deliminatedToken = deliminatedToken.trim();						}						leftDeliminatorIndice = rightDeliminatorIndice + 1;						rightDeliminatorIndice = lineString.indexOf(deliminator, leftDeliminatorIndice);						codeSetVector.lastElement().add(deliminatedToken);					}				}			} catch (IOException erB) {				SystemWindow.println("Fail  erB; Read.codeSet()");				erB.printStackTrace();			}		}		MolecularAssembler.biomoietyDictionaryEntryTerms = (Vector<Vector<String>>) (codeSetVector.clone());	}	public static Vector<String> databaseRecords(String returnType, String codeSet, Vector<Vector<String>> queries) {		String queryString;		if (queries == null) {			queryString = null;		} else {			queryString = queries.elementAt(0).elementAt(0);		}		Vector<String> returnStrings = new Vector<String>();		int maxLines = 100;		String lineString = null;		int foundLineCount = 1;		BufferedReader inputStream = null;		String lineStartDeliminator = "<----Clip Here for Data----->";		String eOF = "EOFdNk.ya8c5d";		boolean stop = false;		if (codeSet.equals("LOINC2.32") && returnType.equals("partial medical code")) {			queryString = "\"" + queryString;		}		try {			inputStream = new BufferedReader(new FileReader(Device.binDir + "Medical_code_sets/" + codeSet + "CodeSet.dat"));			while (!stop && !(lineString = inputStream.readLine()).equals(eOF)) {				if (lineString.equals(lineStartDeliminator)) {					lineString = inputStream.readLine();					returnStrings.add(lineString);					stop = true;				}			}		} catch (Exception er) {			SystemWindow.println("Fail er; Read.codeSet()");			er.printStackTrace();		}		stop = false;		if (returnType.equals("entire database")) {			try {				while (!(lineString = inputStream.readLine()).equals(eOF)) {					returnStrings.add(lineString);				}			} catch (IOException erB) {				SystemWindow.println("Fail  erB; Read.codeSet()");				erB.printStackTrace();			}		} else if (returnType.equals("partial medical code")) {			try {				while (!stop && !(lineString = inputStream.readLine()).equals(eOF)) {					if (lineString.toLowerCase().startsWith(queryString.toLowerCase())) {						returnStrings.add(lineString);						stop = true;					}				}			} catch (Exception er3) {				SystemWindow.println("Fail  er3; Read.codeSet()");				er3.printStackTrace();			}		} else if (returnType.equals("exact medical code")) {			try {				while (!stop && !(lineString = inputStream.readLine()).equals(eOF)) {					if (lineString.toLowerCase().startsWith(queryString.toLowerCase() + "\t")) {						returnStrings.add(lineString);						stop = true;					}				}			} catch (Exception er3) {				SystemWindow.println("Fail  er3; Read.codeSet()");				er3.printStackTrace();			}		} else {			try {				boolean lineContainsClause = false;				boolean allTermClausesFound = false;				int ind1;				int ind2;				while (!stop && !(lineString = inputStream.readLine()).equals(eOF)) {					allTermClausesFound = true;					ind1 = 0;					while (ind1 < queries.size()) {						lineContainsClause = false;						ind2 = 0;						while (!lineContainsClause && ind2 < queries.elementAt(ind1).size()) {							if (lineString.toLowerCase().contains(queries.elementAt(ind1).elementAt(ind2).toLowerCase())) {								lineContainsClause = true;							}							ind2++;						}						if (!lineContainsClause) {							allTermClausesFound = false;						}						ind1++;					}					if (allTermClausesFound) {						returnStrings.add(lineString);						foundLineCount++;					}					if (foundLineCount > maxLines) {						stop = true;					}				}			} catch (Exception er4) {				SystemWindow.println("Fail  er4; Read.codeSet()");				er4.printStackTrace();			}		}		try {			inputStream.close();		} catch (Exception er5) {			SystemWindow.println("Fail  er5; Read.codeSet()");			er5.printStackTrace();		}		return returnStrings;	}	public static void images() throws Exception {		Vector imagesVector = new Vector();		FileInputStream fisImages = null;		BufferedInputStream bisImages = null;		ObjectInputStream oisImages = null;		try {			fisImages = new FileInputStream(new File(Device.binDir + "images/i_VitalityEHR.dat"));			bisImages = new BufferedInputStream(fisImages);			oisImages = new ObjectInputStream(bisImages);		} catch (Exception e) {			SystemWindow.println("Fail at 3: " + e);		}		try {			SystemWindow.println("Reading in SystemFrame.imagesVector");			imagesVector = (Vector) (oisImages.readObject());			SystemWindow.println("Read in imagesVector");		} catch (Exception e) {			SystemWindow.println("imagesVector failed to read-in.");		}		Device.imagesVector = imagesVector;		oisImages.close();		fisImages.close();		bisImages.close();	}	public static void in(String directoryToReadFrom, String dataFilePrefix, byte[] raw) throws Exception {		System.out.println("dataFilePrefix: " + dataFilePrefix);		skeySpec = new SecretKeySpec(rawTrumped, "AES");		String fileName = dataFilePrefix + "_vitality.dat";		Cipher cipher = Cipher.getInstance("AES");		cipher.init(Cipher.DECRYPT_MODE, skeySpec);		ObjectInputStream ois = null;		directoryToReadFrom = directoryToReadFrom + "/";		FileInputStream fis = new FileInputStream(Device.binDir + directoryToReadFrom + fileName);		BufferedInputStream bis = new BufferedInputStream(fis);		CipherInputStream cis = new CipherInputStream(bis, cipher);		ois = new ObjectInputStream(cis);		if (directoryToReadFrom.equals("sys/")) {			try {				Access.rootAdministrator = (Vector) (ois.readObject());				SystemWindow.println("Read.in() rootAdministrator; font is: " + ((String) ((Vector) Access.rootAdministrator.elementAt(3)).elementAt(13)));			} catch (Exception e) {				SystemWindow.println("!Read.in() rootAdministrator");			}		} else if (directoryToReadFrom.equals("usr/")) {			try {				Access.user = (Vector) (ois.readObject());				SystemWindow.println("Read.in() Access.user; fontSize is: " + ((Integer) ((Vector) Access.user.elementAt(3)).elementAt(14)));			} catch (EOFException e) {				SystemWindow.println("!Read.in() Access.user.");			}		} else if (directoryToReadFrom.equals("enc/")) {			try {				Access.patientDataStruct = (Vector) (ois.readObject());				Vector<Vector> timeStampKeyedChartEventInformationVector = new Vector<Vector>();				timeStampKeyedChartEventInformationVector.add(new Vector());				((Vector) (timeStampKeyedChartEventInformationVector.elementAt(0))).add(new Date().toString() + ": opened by " + Access.loggedOnUserID);			} catch (EOFException e) {			}		}		ois.close();	}	public static Vector chart(String dataFilePrefix, byte[] raw) throws Exception {		Vector oisVector = null;		System.out.println("dataFilePrefix: " + dataFilePrefix);		skeySpec = new SecretKeySpec(rawTrumped, "AES");		String fileName = dataFilePrefix + "_vitality.dat";		Cipher cipher = Cipher.getInstance("AES");		cipher.init(Cipher.DECRYPT_MODE, skeySpec);		ObjectInputStream ois = null;		FileInputStream fis = new FileInputStream(Device.binDir + "enc/" + fileName);		BufferedInputStream bis = new BufferedInputStream(fis);		CipherInputStream cis = new CipherInputStream(bis, cipher);		ois = new ObjectInputStream(cis);		try {			oisVector = (Vector) (ois.readObject());			ois.close();		} catch (EOFException e) {			ois.close();		}		return oisVector;	}	public static Vector getUser(String dataFilePrefix, byte[] raw) throws Exception {		Vector oisVector = null;		System.out.println("dataFilePrefix: " + dataFilePrefix);		skeySpec = new SecretKeySpec(rawTrumped, "AES");		String fileName = dataFilePrefix + "_vitality.dat";		Cipher cipher = Cipher.getInstance("AES");		cipher.init(Cipher.DECRYPT_MODE, skeySpec);		ObjectInputStream ois = null;		FileInputStream fis = new FileInputStream(Device.binDir + "usr/" + fileName);		BufferedInputStream bis = new BufferedInputStream(fis);		CipherInputStream cis = new CipherInputStream(bis, cipher);		ois = new ObjectInputStream(cis);		try {			oisVector = (Vector) (ois.readObject());			ois.close();		} catch (EOFException e) {			ois.close();		}		return oisVector;	}	public static void out(String directoryToWriteTo, Object pUserDataObject, String fileName, byte[] raw) throws Exception {		skeySpec2 = new SecretKeySpec(rawTrumped2, "AES");		Cipher cipher = Cipher.getInstance("AES");		cipher.init(Cipher.ENCRYPT_MODE, skeySpec2);		FileOutputStream fos = new FileOutputStream(Device.binDir + directoryToWriteTo + "/" + fileName);		BufferedOutputStream bos = new BufferedOutputStream(fos);		CipherOutputStream cos = new CipherOutputStream(bos, cipher);		ObjectOutputStream oos = new ObjectOutputStream(cos);		try {			oos.writeUnshared(pUserDataObject);			oos.flush();			oos.close();		} catch (IOException e) {			SystemWindow.println("e: " + e);		}	}			public static void copyDestFileIfNotExist(String source, String dest) throws IOException {		FileChannel inputChannel = null;		FileChannel outputChannel = null;		File destFile = new File(dest);				if (!destFile.exists()) {			try {				inputChannel = new FileInputStream(new File(source)).getChannel();				outputChannel = new FileOutputStream(new File(dest)).getChannel();				outputChannel.transferFrom(inputChannel, 0, inputChannel.size());			} catch (IOException e) {				System.out.println("error copying " + source + " to " + dest);				e.printStackTrace();				inputChannel.close();				outputChannel.close();			}		}	}}// EOF