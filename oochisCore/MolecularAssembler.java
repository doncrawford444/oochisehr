/* * Copyright 2014 Donald Ray Crawford Jr. *  * This file is part of Oochis EHR. *  * Oochis EHR is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with Oochis EHR.  If not, see <http://www.gnu.org/licenses/>. */package oochisCore;import java.awt.Point;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.util.Vector;import java.util.regex.Matcher;import java.util.regex.Pattern;public class MolecularAssembler {	static Vector<Point[]> primaryNetworksEndPoints;	static Vector<Double> primaryNetworksDistancesBetweenEndPoints = new Vector<Double>();	static Vector<Vector<Vector<String[]>>> primaryNetworksPaths;	static Vector<Vector<Vector<Point>>> primaryNetworksPointLocations;	static Vector<Vector<Vector<String[]>>> secondaryNetworksPaths;	static Vector<Vector<Vector<String[]>>> tertiaryNetworks;	static Vector<int[]> tertiaryNetworksPolyLinePointsX;	static Vector<int[]> tertiaryNetworksPolyLinePointsY;	static Vector<Vector<Vector<Vector<Point>>>> primaryNetworksLinearPointLocations = new Vector<Vector<Vector<Vector<Point>>>>();	static Vector<Vector<Vector<Vector<Point>>>> secondaryNetworksLinearPointLocations = new Vector<Vector<Vector<Vector<Point>>>>();	static Vector<Vector<Vector<Vector<String[]>>>> primaryNetworksLinearPathsFromRootToCommonBiomoieties = new Vector<Vector<Vector<Vector<String[]>>>>();	static Vector<Vector<Vector<Vector<String[]>>>> secondaryNetworksLinearPathsFromRootToCommonBiomoieties = new Vector<Vector<Vector<Vector<String[]>>>>();	static Vector copiedBiomoietyGridLoci;	static Vector<Vector<Integer>> primaryNetworksCommonBiomoietyIndiceLocations;	static Vector<Vector<Integer>> secondaryNetworksCommonBiomoietyIndiceLocations;	static Vector locationsOfIdenticalBiomoieties;	static int numElements;	static int testAbstractBlurbInd = 0;	static boolean overRidePubMedRetrievalWithLocalFiles = true;	static Vector<Vector<Vector<String[]>>> publicationSentencesWithMoreThanOneBiomoiety = new Vector<Vector<Vector<String[]>>>();	static Vector<Vector<Vector<String[]>>> biomoietyPairs;	static Vector<Vector<Vector<String[]>>> primaryNetworksBiomoietyPairs;	static Vector<Vector<Vector<String[]>>> primaryNetworksBiomoietyGridLoci;	static Vector<Vector<Vector<String[]>>> secondaryNetworksBiomoietyGridLoci;	static boolean calculateSecondaryNetworks = false;	static Vector<String[]> referencePublications;	static Vector<String[]> biomoietyDictionaryAliasTerms = new Vector<String[]>();	public static int theTotalNumberOfPublications;	static Vector<Vector<String>> biomoietyDictionaryEntryTerms = new Vector<Vector<String>>(28000, 20);	static Vector<Vector<String>> sentencesInTheAbstract = new Vector<Vector<String>>();	static Vector biomoietyGridLoci = new Vector();	MolecularAssembler() {	}	public static void makeDictionaryTermVector() {		int biomoietyDictionarySize = biomoietyDictionaryEntryTerms.size();		int dictionaryInd = 0;		while (dictionaryInd < biomoietyDictionarySize) {			String[] dictionaryTermStringArray = new String[5];			dictionaryTermStringArray[0] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(1).trim();			dictionaryTermStringArray[1] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(1).trim();			dictionaryTermStringArray[2] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(0).trim();			dictionaryTermStringArray[3] = "approved name";			dictionaryTermStringArray[4] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(4).trim();			biomoietyDictionaryAliasTerms.add(dictionaryTermStringArray);			int aliasDeliminatorIndice = -1;			String aliases = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(2).trim();			boolean anotherAliasExists = false;			if (aliases != null && !aliases.equals("")) {				anotherAliasExists = true;			}			while (anotherAliasExists) {				dictionaryTermStringArray = new String[5];				aliasDeliminatorIndice = aliases.indexOf(", ");				if (aliasDeliminatorIndice == -1) {					aliasDeliminatorIndice = 1;					anotherAliasExists = false;					dictionaryTermStringArray[0] = aliases.trim();				} else {					dictionaryTermStringArray[0] = aliases.substring(0, aliasDeliminatorIndice).trim();					aliases = aliases.substring(aliasDeliminatorIndice + 2, aliases.length()).trim();				}				dictionaryTermStringArray[1] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(1).trim();				dictionaryTermStringArray[2] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(0).trim();				dictionaryTermStringArray[3] = "abbreviated synonym";				dictionaryTermStringArray[4] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(4).trim();				biomoietyDictionaryAliasTerms.add(dictionaryTermStringArray);			}			int nameAliasDeliminatorIndice = -1;			String nameAliases = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(3).replace("\", \";\", \"", "").trim();			boolean anotherNameAliasExists = false;			if (nameAliases != null && !nameAliases.equals("")) {				anotherNameAliasExists = true;			}			while (anotherNameAliasExists) {				dictionaryTermStringArray = new String[5];				nameAliasDeliminatorIndice = nameAliases.indexOf("\", \"");				if (nameAliasDeliminatorIndice == -1) {					nameAliasDeliminatorIndice = 1;					anotherNameAliasExists = false;					dictionaryTermStringArray[0] = nameAliases.trim().replace("\"", "");				} else {					dictionaryTermStringArray[0] = nameAliases.substring(0, nameAliasDeliminatorIndice).trim().replace("\"", "");					nameAliases = nameAliases.substring(nameAliasDeliminatorIndice + 4, nameAliases.length()).trim();				}				dictionaryTermStringArray[1] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(1).trim();				dictionaryTermStringArray[2] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(0).trim();				dictionaryTermStringArray[3] = "synonym";				dictionaryTermStringArray[4] = biomoietyDictionaryEntryTerms.elementAt(dictionaryInd).elementAt(4).trim();				biomoietyDictionaryAliasTerms.add(dictionaryTermStringArray);			}			dictionaryInd++;		}	}	public static Vector<Vector<String[]>> getBiomoietyLocations(Vector<String[]> pPublicationBlurbs) {		Vector<String[]> unorderedArticle;		Vector<String[]> orderedArticle;		Vector<Vector<String[]>> orderedArticles = new Vector<Vector<String[]>>();		String[] articleTermAttributes;		String searchTerm;		int numberOfDictionaryTerms = biomoietyDictionaryAliasTerms.size();		int searchStartIndiceInAbstract;		int foundTermIndiceInAbstract;		int dictionaryTermInd;		String abstractText;		int abstractTextLength;		boolean includeSynonyms;		boolean find1;		boolean find2;		int pubInd = 0;		while (pubInd < pPublicationBlurbs.size()) {			System.out.println(pubInd + " of " + pPublicationBlurbs.size());			unorderedArticle = new Vector<String[]>();			orderedArticle = new Vector<String[]>();			articleTermAttributes = new String[10];			unorderedArticle.add(pPublicationBlurbs.elementAt(pubInd));			searchStartIndiceInAbstract = 0;			foundTermIndiceInAbstract = 0;			dictionaryTermInd = 0;			abstractText = pPublicationBlurbs.elementAt(pubInd)[4];			abstractTextLength = abstractText.length();			find1 = false;			find2 = false;			while (dictionaryTermInd < numberOfDictionaryTerms) {				searchTerm = biomoietyDictionaryAliasTerms.elementAt(dictionaryTermInd)[0];				includeSynonyms = true;				if (!Device.device.workspace.decisionSupportWindow.includeMolecularAbbreviationsJToggleButton.isSelected()) {					if (biomoietyDictionaryAliasTerms.elementAt(dictionaryTermInd)[3].equals("abbreviated synonym")) {						includeSynonyms = false;					}				}				if (includeSynonyms & abstractText.substring(searchStartIndiceInAbstract).contains(searchTerm)) {					foundTermIndiceInAbstract = abstractText.indexOf(searchTerm, searchStartIndiceInAbstract);					find1 = false;					find2 = false;					if ((foundTermIndiceInAbstract == 0 || abstractText.charAt(foundTermIndiceInAbstract - 1) == ' ') && abstractTextLength > foundTermIndiceInAbstract + searchTerm.length() - 1 && (abstractText.charAt(foundTermIndiceInAbstract + searchTerm.length()) == ' ' | abstractText.charAt(foundTermIndiceInAbstract + searchTerm.length()) == ',' | abstractText.charAt(foundTermIndiceInAbstract + searchTerm.length()) == '.')) {						find1 = true;					} else if (foundTermIndiceInAbstract != 0 && (abstractText.charAt(foundTermIndiceInAbstract - 1) == '(' && abstractTextLength > foundTermIndiceInAbstract + searchTerm.length() - 1 && abstractText.charAt(foundTermIndiceInAbstract + searchTerm.length()) == ')')) {						find2 = true;					}					if (find1 || find2) {						articleTermAttributes[0] = searchTerm.toString();						articleTermAttributes[1] = biomoietyDictionaryAliasTerms.elementAt(dictionaryTermInd)[1];						articleTermAttributes[2] = biomoietyDictionaryAliasTerms.elementAt(dictionaryTermInd)[2];						articleTermAttributes[3] = (String.valueOf(foundTermIndiceInAbstract)).toString();						articleTermAttributes[4] = (String.valueOf(foundTermIndiceInAbstract + searchTerm.length() - 1)).toString();						articleTermAttributes[5] = biomoietyDictionaryAliasTerms.elementAt(dictionaryTermInd)[4];						articleTermAttributes[6] = biomoietyDictionaryAliasTerms.elementAt(dictionaryTermInd)[3];						articleTermAttributes[7] = String.valueOf(dictionaryTermInd);						unorderedArticle.add(articleTermAttributes.clone());						searchStartIndiceInAbstract = foundTermIndiceInAbstract + 1;						dictionaryTermInd--;					} else {						searchStartIndiceInAbstract = 0;					}				} else {					searchStartIndiceInAbstract = 0;				}				dictionaryTermInd++;			}			int numBiomoieties1 = unorderedArticle.size() - 1;			int ind;			int smallestValue;			int smallestInd = -1;			String addedInds = "|";			orderedArticle.add(unorderedArticle.elementAt(0));			while (orderedArticle.size() - 1 < numBiomoieties1) {				smallestValue = Integer.MAX_VALUE;				ind = 1;				while (ind <= numBiomoieties1) {					if (!addedInds.contains("|" + ind + "|") && Integer.parseInt(unorderedArticle.elementAt(ind)[3]) < smallestValue) {						smallestValue = Integer.parseInt(unorderedArticle.elementAt(ind)[3]);						smallestInd = ind;					}					ind++;				}				orderedArticle.add(unorderedArticle.elementAt(smallestInd));				addedInds = addedInds + smallestInd + "|";			}			if (orderedArticle.size() != 1) {				orderedArticles.add(orderedArticle);			}			pubInd++;		}		return orderedArticles;	}	public static Vector<Vector<String[]>> getPublicationsAndTagTheBiomoieties(String parsedQuery) {		System.out.println("getPublicationsAndTagTheBiomoieties() called");		BufferedReader nLMConnectionBufferedReader = createNLMFileConnectionBufferedReader(parsedQuery);		System.out.println("nLMConnectionBufferedReader: " + nLMConnectionBufferedReader);		String[] tag = new String[20];		tag[0] = "      ";		tag[1] = "PMID- ";		tag[2] = "DP  - ";		tag[3] = "TI  - ";		tag[4] = "AB  - ";		tag[5] = "AD  - ";		tag[6] = "JT  - ";		tag[7] = "AU  - ";		tag[8] = "SO  - ";		tag[9] = "PT  - ";		String lineString = "nulled";		int publicationInd = 1;		String[] publicationBlurb = null;		Vector<String[]> publicationBlurbs = new Vector<String[]>();		boolean tagFound = false;		int publicationIndTicNum = 0;		int publicationIndMax = 60;		if (calculateSecondaryNetworks) {			publicationIndMax = 60;		}		if (nLMConnectionBufferedReader != null) {			try {				lineString = nLMConnectionBufferedReader.readLine();			} catch (IOException e) {				e.printStackTrace();			}			while (lineString != null && publicationInd < publicationIndMax) {				if (lineString.startsWith(tag[1])) {					publicationIndTicNum++;					if (publicationIndTicNum == 10) {						Device.device.workspace.decisionSupportWindow.addTalkbackText("Reading abstract " + publicationInd, null, false);						System.out.println("Reading abstract " + publicationInd);						Device.device.workspace.decisionSupportWindow.talkbackJPanel.paintImmediately(0, 0, Device.device.workspace.decisionSupportWindow.talkbackJPanel.getWidth(), Device.device.workspace.decisionSupportWindow.talkbackJPanel.getHeight());						publicationIndTicNum = 0;					}					if (publicationBlurb != null && publicationBlurb[4] != null && !publicationBlurb[4].equals("")) {						publicationBlurbs.add(publicationBlurb);					}					publicationBlurb = new String[10];					int ind = 0;					while (ind < 10) {						publicationBlurb[ind] = "nulled";						ind++;					}					publicationInd++;					publicationBlurb[1] = lineString.substring(tag[1].length());					try {						lineString = nLMConnectionBufferedReader.readLine();					} catch (IOException e) {						e.printStackTrace();					}				} else if (publicationBlurb != null) {					tagFound = false;					int tagInded = 2;					while (!tagFound && tagInded < 10) {						if (lineString.startsWith(tag[tagInded])) {							tagFound = true;							publicationBlurb[tagInded] = lineString.substring(tag[tagInded].length());							try {								lineString = nLMConnectionBufferedReader.readLine();							} catch (IOException e) {								e.printStackTrace();							}							while (lineString.startsWith(tag[0])) {								publicationBlurb[tagInded] = publicationBlurb[tagInded] + " " + lineString.substring(tag[0].length());								try {									lineString = nLMConnectionBufferedReader.readLine();								} catch (IOException e) {									e.printStackTrace();								}							}						}						tagInded++;					}					if (!tagFound) {						try {							lineString = nLMConnectionBufferedReader.readLine();						} catch (IOException e) {							e.printStackTrace();						}					}				} else {					try {						lineString = nLMConnectionBufferedReader.readLine();					} catch (IOException e) {						e.printStackTrace();					}				}			}		}		System.out.println("getPublicationsAndTagTheBiomoieties() done");		return getBiomoietyLocations(publicationBlurbs);	}	public static Vector<Vector<Vector<String[]>>> translateArticlesWithBiomoietiesToArticleSentencesWithMoreThanOneBiomoiety(Vector<Vector<String[]>> articles) {		publicationSentencesWithMoreThanOneBiomoiety = new Vector<Vector<Vector<String[]>>>();		publicationSentencesWithMoreThanOneBiomoiety.add(null);		Vector<Vector<Vector<String[]>>> zeroOrderPathways = new Vector<Vector<Vector<String[]>>>();		int articleInd = 1;		int numArticles = articles.size();		int biomoietyInArticleInd = 1;		int numBiomoietiesInAbstract;		Vector<String[]> article;		String articleText;		int periodIndice;		Vector<Integer> allPeriodIndices;		int pInd;		zeroOrderPathways.add(null);		biomoietyInArticleInd = 1;		Vector<Vector<String[]>> newArticleVector;		int biomoietyStringArrayInd;		while (articleInd < numArticles) {			article = articles.elementAt(articleInd);			referencePublications.add(article.elementAt(0));			biomoietyStringArrayInd = 1;			while (biomoietyStringArrayInd < article.size()) {				article.elementAt(biomoietyStringArrayInd)[8] = String.valueOf(referencePublications.size() - 1);				biomoietyStringArrayInd++;			}			articleText = article.elementAt(0)[4];			numBiomoietiesInAbstract = article.size();			newArticleVector = new Vector<Vector<String[]>>();			newArticleVector.add(new Vector<String[]>());			newArticleVector.elementAt(0).add(new String[1]);			biomoietyInArticleInd = 1;			allPeriodIndices = new Vector<Integer>();			periodIndice = -1;			pInd = 0;			while ((periodIndice = articleText.indexOf(". ", periodIndice + 4)) != -1) {				allPeriodIndices.add(periodIndice);				pInd++;			}			if (allPeriodIndices.size() == 0) {				allPeriodIndices.add(articleText.length());			}			if (allPeriodIndices.elementAt(allPeriodIndices.size() - 1) != articleText.length()) {				allPeriodIndices.add(articleText.length());			}			if (allPeriodIndices.size() == 1) {				while (biomoietyInArticleInd < numBiomoietiesInAbstract) {					newArticleVector.add(new Vector<String[]>());					newArticleVector.lastElement().add(article.elementAt(0));					newArticleVector.elementAt(biomoietyInArticleInd).add(article.elementAt(biomoietyInArticleInd));					biomoietyInArticleInd++;				}			} else {				pInd = 0;				while (biomoietyInArticleInd < numBiomoietiesInAbstract && pInd < allPeriodIndices.size()) {					if (biomoietyInArticleInd < numBiomoietiesInAbstract && Integer.parseInt(article.elementAt(biomoietyInArticleInd)[3]) < allPeriodIndices.elementAt(pInd)) {						newArticleVector.add(new Vector<String[]>());						newArticleVector.lastElement().add(article.elementAt(0));					}					int biomoietyInSentenceInd = 0;					while (biomoietyInArticleInd < numBiomoietiesInAbstract && Integer.parseInt(article.elementAt(biomoietyInArticleInd)[3]) < allPeriodIndices.elementAt(pInd)) {						biomoietyInSentenceInd++;						if (biomoietyInSentenceInd == 1) {							newArticleVector.lastElement().add(article.elementAt(biomoietyInArticleInd));						} else if (Integer.parseInt(article.elementAt(biomoietyInArticleInd)[3]) == Integer.parseInt(article.elementAt(biomoietyInArticleInd - 1)[3])) {							int ind = 0;							String[] concatenatedBiomoietyArray = new String[newArticleVector.lastElement().lastElement().length + 10];							while (ind < newArticleVector.lastElement().lastElement().length) {								concatenatedBiomoietyArray[ind] = newArticleVector.lastElement().lastElement()[ind];								ind++;							}							int ind2 = 0;							while (ind2 < 10) {								concatenatedBiomoietyArray[ind + ind2] = article.elementAt(biomoietyInArticleInd)[ind2];								ind2++;							}							newArticleVector.lastElement().setElementAt(concatenatedBiomoietyArray, newArticleVector.lastElement().size() - 1);						} else {							newArticleVector.lastElement().add(article.elementAt(biomoietyInArticleInd));						}						biomoietyInArticleInd++;					}					pInd++;				}			}			newArticleVector.elementAt(0).elementAt(0)[0] = String.valueOf(referencePublications.size() - 1);			zeroOrderPathways.add(newArticleVector);			articleInd++;		}		int indya = 1;		int indyb = 0;		boolean articleHasAtLeastOneSentencesWithMoreThanOneBiomoiety;		while (indya < zeroOrderPathways.size()) {			articleHasAtLeastOneSentencesWithMoreThanOneBiomoiety = false;			indyb = 0;			while (!articleHasAtLeastOneSentencesWithMoreThanOneBiomoiety && indyb < zeroOrderPathways.elementAt(indya).size()) {				if (zeroOrderPathways.elementAt(indya).elementAt(indyb).size() > 2) {					publicationSentencesWithMoreThanOneBiomoiety.add(new Vector<Vector<String[]>>());					publicationSentencesWithMoreThanOneBiomoiety.lastElement().add(zeroOrderPathways.elementAt(indya).elementAt(0));					articleHasAtLeastOneSentencesWithMoreThanOneBiomoiety = true;				}				indyb++;			}			indyb = 0;			while (indyb < zeroOrderPathways.elementAt(indya).size()) {				if (zeroOrderPathways.elementAt(indya).elementAt(indyb).size() > 2) {					publicationSentencesWithMoreThanOneBiomoiety.lastElement().add(zeroOrderPathways.elementAt(indya).elementAt(indyb));				}				indyb++;			}			indya++;		}		return publicationSentencesWithMoreThanOneBiomoiety;	}	public static Vector translateArticleSentencesWithMoreThanOneBiomoietyToGridVector(Vector<Vector<Vector<String[]>>> firstOrderPathways) {		Vector<String[]> sentenceVector;		biomoietyPairs = new Vector<Vector<Vector<String[]>>>();		biomoietyGridLoci = new Vector();		int articleInd = 1;		int sentenceInd = 1;		int biomoietyInd = 1;		while (articleInd < publicationSentencesWithMoreThanOneBiomoiety.size()) {			sentenceInd = 1;			while (sentenceInd < publicationSentencesWithMoreThanOneBiomoiety.elementAt(articleInd).size()) {				sentenceVector = publicationSentencesWithMoreThanOneBiomoiety.elementAt(articleInd).elementAt(sentenceInd);				biomoietyInd = 1;				while (biomoietyInd < sentenceVector.size()) {					if (biomoietyInd < sentenceVector.size() - 1) {						biomoietyPairs.add(new Vector(2, 1));						((Vector) (biomoietyPairs.lastElement())).add(new Vector(2, 1));						((Vector) (biomoietyPairs.lastElement())).add(new Vector(2, 1));						((Vector) (((Vector) (biomoietyPairs.lastElement())).elementAt(0))).add(sentenceVector.elementAt(biomoietyInd));						((Vector) (((Vector) (biomoietyPairs.lastElement())).elementAt(1))).add(sentenceVector.elementAt(biomoietyInd + 1));					}					biomoietyInd++;				}				sentenceInd++;			}			articleInd++;		}		if (!calculateSecondaryNetworks) {			primaryNetworksBiomoietyPairs = biomoietyPairs;		}		String[] biomoietyGridLociRoot;		boolean addedFirstBiomoietyAsRoot;		boolean addedSecondBiomoietyAsRoot;		int ind = 0;		int a = 0;		while (a < biomoietyPairs.size()) {			addedFirstBiomoietyAsRoot = false;			addedSecondBiomoietyAsRoot = false;			ind = 0;			while (!(addedFirstBiomoietyAsRoot && addedSecondBiomoietyAsRoot) && ind < biomoietyGridLoci.size()) {				biomoietyGridLociRoot = (String[]) (((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind))).elementAt(0))).elementAt(0));				Vector<Integer> location = new Vector<Integer>();				location.add(ind);				location.add(0);				if (!addedFirstBiomoietyAsRoot && biomoietyPairs.elementAt(a).elementAt(0).elementAt(0)[2].equals(biomoietyGridLociRoot[2])) {					addNewBiomoietyPairToExistingRootFan(biomoietyPairs.elementAt(a).elementAt(0).elementAt(0), biomoietyPairs.elementAt(a).elementAt(1).elementAt(0), location);					addedFirstBiomoietyAsRoot = true;				} else if (!addedSecondBiomoietyAsRoot && biomoietyPairs.elementAt(a).elementAt(1).elementAt(0)[2].equals(biomoietyGridLociRoot[2])) {					addNewBiomoietyPairToExistingRootFan(biomoietyPairs.elementAt(a).elementAt(1).elementAt(0), biomoietyPairs.elementAt(a).elementAt(0).elementAt(0), location);					addedSecondBiomoietyAsRoot = true;				}				ind++;			}			if (biomoietyPairs.elementAt(a).elementAt(0).elementAt(0)[2].equals(biomoietyPairs.elementAt(a).elementAt(1).elementAt(0)[2]) && !(addedFirstBiomoietyAsRoot || addedSecondBiomoietyAsRoot)) {				addNewBiomoietyPairAsNewRootFan(biomoietyPairs.elementAt(a).elementAt(0).elementAt(0), biomoietyPairs.elementAt(a).elementAt(1).elementAt(0));			} else {				if (!addedFirstBiomoietyAsRoot) {					addNewBiomoietyPairAsNewRootFan(biomoietyPairs.elementAt(a).elementAt(0).elementAt(0), biomoietyPairs.elementAt(a).elementAt(1).elementAt(0));				}				if (!addedSecondBiomoietyAsRoot) {					addNewBiomoietyPairAsNewRootFan(biomoietyPairs.elementAt(a).elementAt(1).elementAt(0), biomoietyPairs.elementAt(a).elementAt(0).elementAt(0));				}			}			a++;		}		String[] biomoietyGridLociPairNodeAtInd;		String[] biomoietyGridLociPairRootAtInd;		String[] biomoietyGridLociRootAtInd2;		boolean duplicatedBiomoietyExists;		int ind2;		int ind3;		ind = 0;		while (ind < biomoietyGridLoci.size()) {			if (((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind))).elementAt(1))).size() == 1) {				biomoietyGridLociPairNodeAtInd = ((String[]) (((Vector) (((Vector) (((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind))).elementAt(1))).elementAt(0))).elementAt(0))).elementAt(0)));				biomoietyGridLociPairRootAtInd = ((String[]) (((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind))).elementAt(0))).elementAt(0)));				duplicatedBiomoietyExists = false;				ind2 = 0;				while (ind2 < biomoietyGridLoci.size()) {					biomoietyGridLociRootAtInd2 = ((String[]) (((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind2))).elementAt(0))).elementAt(0)));					if (ind != ind2 && biomoietyGridLociPairNodeAtInd[2].equals(biomoietyGridLociRootAtInd2[2])) {						ind3 = 0;						while (ind3 < ((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind2))).elementAt(1))).size()) {							if (biomoietyGridLociPairRootAtInd[2].equals(((String[]) (((Vector) (((Vector) (((Vector) (((Vector) (biomoietyGridLoci.elementAt(ind2))).elementAt(1))).elementAt(ind3))).elementAt(0))).elementAt(0)))[2])) {								duplicatedBiomoietyExists = true;							}							ind3++;						}					}					ind2++;				}				if (duplicatedBiomoietyExists) {					biomoietyGridLoci.remove(ind);					ind--;				}			}			ind++;		}		copiedBiomoietyGridLoci = copyComplexStringArrayVector(biomoietyGridLoci);		ind = 0;		while (ind < biomoietyGridLoci.size()) {			if (assemble(biomoietyGridLoci, ((Vector) (biomoietyGridLoci.elementAt(ind))), ind, new Vector<String>(), new Vector<Integer>(), false)) {				biomoietyGridLoci.remove(ind);				ind--;			}			ind++;		}		numElements = 0;		int indWithLargestCount = 0;		int countOfVectorElements = 0;		int largestCountOfVectorElements = 0;		Vector sizeOrderedBiomoietyGridLoci = new Vector();		int bInd;		while (!biomoietyGridLoci.isEmpty()) {			indWithLargestCount = 0;			bInd = 0;			largestCountOfVectorElements = 0;			while (bInd < biomoietyGridLoci.size()) {				numElements = 0;				countOfVectorElements = countOfStringArrayVectorElements((Vector) (biomoietyGridLoci.elementAt(bInd)));				if (largestCountOfVectorElements < countOfVectorElements) {					largestCountOfVectorElements = countOfVectorElements;					indWithLargestCount = bInd;				}				bInd++;			}			sizeOrderedBiomoietyGridLoci.add(copyComplexStringArrayVector((Vector) (biomoietyGridLoci.elementAt(indWithLargestCount))));			biomoietyGridLoci.remove(indWithLargestCount);		}		return sizeOrderedBiomoietyGridLoci;	}	public static int countOfStringArrayVectorElements(Vector vector) {		int ind = 0;		if (!vector.isEmpty() && vector.elementAt(0) instanceof String[]) {			numElements++;		} else {			while (ind < vector.size()) {				countOfStringArrayVectorElements((Vector) (vector.elementAt(ind)));				ind++;			}		}		return numElements;	}	private static boolean assemble(Vector targetStructure, Vector addingStructure, int addingStructureInd, Vector<String> hUGOIDsOfBiomoietiesFromRoot, Vector<Integer> location, boolean added) {		int nodeInd = 0;		int biomoietyGridLoci2Size = targetStructure.size();		int ind = biomoietyGridLoci2Size - 1;		boolean isAddingStructureHUGOIDAlreadyInLinearBiomoietySequence;		int hUGOIDsOfBiomoietiesFromRootInd;		while (ind >= 0) {			if (!(location.isEmpty() && addingStructureInd == ind)) {				if (targetStructure.elementAt(ind) instanceof Vector) {					location.add(ind);					if (assemble((Vector) (targetStructure.elementAt(ind)), addingStructure, -1, hUGOIDsOfBiomoietiesFromRoot, location, added)) {						added = true;					}					location.remove(location.size() - 1);				} else if (targetStructure.elementAt(ind) instanceof String[]) {					if (location.size() > 2 && ind == 0) {						String[] addingStructureRootBiomoiety = ((String[]) (((Vector) (addingStructure.elementAt(0))).elementAt(0)));						isAddingStructureHUGOIDAlreadyInLinearBiomoietySequence = false;						hUGOIDsOfBiomoietiesFromRootInd = 0;						while (!isAddingStructureHUGOIDAlreadyInLinearBiomoietySequence && hUGOIDsOfBiomoietiesFromRootInd < hUGOIDsOfBiomoietiesFromRoot.size()) {							if (hUGOIDsOfBiomoietiesFromRoot.elementAt(hUGOIDsOfBiomoietiesFromRootInd).equals(addingStructureRootBiomoiety[2])) {								isAddingStructureHUGOIDAlreadyInLinearBiomoietySequence = true;							}							hUGOIDsOfBiomoietiesFromRootInd++;						}						if (!isAddingStructureHUGOIDAlreadyInLinearBiomoietySequence && addingStructureRootBiomoiety[2].equals(((String[]) (targetStructure.elementAt(ind)))[2])) {							hUGOIDsOfBiomoietiesFromRoot.add(addingStructureRootBiomoiety[2]);							String[] targetStructureRootBiomoiety = ((String[]) (targetStructure.elementAt(ind)));							Vector r = biomoietyGridLoci;							int indle = 0;							String lead = "biomoietyGridLoci";							while (indle < location.size() - 4) {								lead = lead + ".e(" + location.elementAt(indle) + ")";								r = ((Vector) (r.elementAt(location.elementAt(indle))));								indle++;							}							String[] targetStructureRoot = ((String[]) (((Vector) (((Vector) (((Vector) (((Vector) (r.elementAt(location.elementAt(indle)))).elementAt(location.elementAt(indle + 1)))).elementAt(location.elementAt(indle + 2)))).elementAt(0))).elementAt(0)));							String[] targetStructureRootRoot = ((String[]) (((Vector) (((Vector) (r.elementAt(location.elementAt(indle)))).elementAt(0))).elementAt(0)));							if (!(targetStructureRootBiomoiety[3] + targetStructureRootBiomoiety[8]).equals(addingStructureRootBiomoiety[3] + addingStructureRootBiomoiety[8])) {							} else {							}							Vector addingStructureClone = copyComplexStringArrayVector(addingStructure);							int indy = 0;							while (indy < ((Vector) (addingStructureClone.elementAt(1))).size()) {								if (((String[]) (((Vector) (((Vector) (((Vector) (addingStructureClone.elementAt(1))).elementAt(indy))).elementAt(0))).elementAt(0)))[2].equals(targetStructureRootRoot[2])) {									((Vector) (addingStructureClone.elementAt(1))).remove(indy);								}								indy++;							}							((Vector) (((Vector) (r.elementAt(location.elementAt(indle)))).elementAt(location.elementAt(indle + 1)))).setElementAt(addingStructureClone, location.elementAt(indle + 2));							added = true;						}					}				} else if (((Vector) (((Vector) (targetStructure.elementAt(0))).elementAt(0))).elementAt(ind) == null) {					System.out.println("Unexpected null: traM.assemble()");				} else {					System.out.println("Unexpected element type: traM.assemble()");				}			}			ind--;		}		return added;	}	public static Vector<Vector<Integer>> fillCommonBiomoietyLocationVector(Vector biomoietyGridLociOne, Vector biomoietyGridLociTwo, Vector<Vector<Integer>> commonBiomoietyIndiceLocations, Vector<Integer> location) {		int ind = 0;		while (ind < biomoietyGridLociOne.size()) {			if (ind == 0 && biomoietyGridLociOne.elementAt(0) instanceof String[]) {				if (searchForBiomoiety(biomoietyGridLociTwo, ((String[]) (biomoietyGridLociOne.elementAt(0)))[2], new Vector<Integer>(), false)) {					commonBiomoietyIndiceLocations.add((Vector<Integer>) (location.clone()));				}			} else if (biomoietyGridLociOne.elementAt(ind) instanceof Vector) {				location.add(ind);				fillCommonBiomoietyLocationVector((Vector) (biomoietyGridLociOne.elementAt(ind)), biomoietyGridLociTwo, commonBiomoietyIndiceLocations, location);				location.remove(location.size() - 1);			}			ind++;		}		return commonBiomoietyIndiceLocations;	}	private static boolean searchForBiomoiety(Vector vector, String biomoietyHUGOID, Vector<Integer> location, boolean found) {		int ind = 0;		while (ind < vector.size()) {			if (ind == 0 && vector.elementAt(0) instanceof String[] && ((String[]) (vector.elementAt(0)))[2].equals(biomoietyHUGOID)) {				found = true;			} else if (vector.elementAt(ind) instanceof Vector) {				location.add(ind);				found = searchForBiomoiety(((Vector) (vector.elementAt(ind))), biomoietyHUGOID, location, found);				location.remove(location.size() - 1);			}			ind++;		}		return found;	}	public static void createLinearPathsBetweenRootAndCommonBiomoieties(Vector<Vector<Integer>> commonBiomoietyLocations, String primaryOrSecondaryNetworks) {		Vector<Vector<Vector<Vector<String[]>>>> linearPathsBetweenRootAndCommonBiomoieties = new Vector<Vector<Vector<Vector<String[]>>>>();		Vector<Vector<Vector<Integer>>> commonBiomoietyLocationsOrderedIntoStructures = new Vector<Vector<Vector<Integer>>>();		Vector<Vector<Vector<Vector<Point>>>> linearPathsBetweenRootAndCommonBiomoietyPointLocations = new Vector<Vector<Vector<Vector<Point>>>>();		commonBiomoietyLocationsOrderedIntoStructures.add(new Vector<Vector<Integer>>());		int networkStructureInd = 0;		int commonBiomoietyInd = 0;		while (commonBiomoietyInd < commonBiomoietyLocations.size()) {			int rInd0 = ((Integer) (((Vector<Integer>) (commonBiomoietyLocations.elementAt(commonBiomoietyInd))).elementAt(0)));			if (networkStructureInd != rInd0) {				commonBiomoietyLocationsOrderedIntoStructures.add(new Vector<Vector<Integer>>());				networkStructureInd = rInd0;			}			commonBiomoietyLocationsOrderedIntoStructures.lastElement().add(commonBiomoietyLocations.elementAt(commonBiomoietyInd));			commonBiomoietyInd++;		}		Vector r;		Vector s;		networkStructureInd = 0;		int locationInd;		while (networkStructureInd < commonBiomoietyLocationsOrderedIntoStructures.size()) {			linearPathsBetweenRootAndCommonBiomoieties.add(new Vector<Vector<Vector<String[]>>>());			linearPathsBetweenRootAndCommonBiomoietyPointLocations.add(new Vector<Vector<Vector<Point>>>());			commonBiomoietyInd = 0;			while (commonBiomoietyInd < commonBiomoietyLocationsOrderedIntoStructures.elementAt(networkStructureInd).size()) {				linearPathsBetweenRootAndCommonBiomoieties.lastElement().add(new Vector<Vector<String[]>>());				linearPathsBetweenRootAndCommonBiomoietyPointLocations.lastElement().add(new Vector<Vector<Point>>());				if (primaryOrSecondaryNetworks.equals("primary networks")) {					r = primaryNetworksBiomoietyGridLoci;					s = Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.primaryNetworksAllBiomoietyPointLocations;				} else {					r = secondaryNetworksBiomoietyGridLoci;					s = Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.secondaryNetworksAllBiomoietyPointLocations;				}				int numElementsInLocation = commonBiomoietyLocationsOrderedIntoStructures.elementAt(networkStructureInd).elementAt(commonBiomoietyInd).size();				locationInd = 0;				String pathString = "";				while (locationInd < numElementsInLocation - 2) {					int rInd = ((Integer) (((Vector<Integer>) (commonBiomoietyLocationsOrderedIntoStructures.elementAt(networkStructureInd).elementAt(commonBiomoietyInd))).elementAt(locationInd)));					if (((Vector) (r.elementAt(0))).elementAt(0) instanceof String[]) {						linearPathsBetweenRootAndCommonBiomoieties.lastElement().lastElement().add(((Vector) (r.elementAt(0))));						linearPathsBetweenRootAndCommonBiomoietyPointLocations.lastElement().lastElement().add(((Vector) (s.elementAt(0))));						pathString = pathString + ((String[]) (((Vector) (r.elementAt(0))).elementAt(0)))[0] + ", ";					}					r = ((Vector) (r.elementAt(rInd)));					s = ((Vector) (s.elementAt(rInd)));					locationInd++;				}				int rInd = ((Integer) (((Vector<Integer>) (commonBiomoietyLocationsOrderedIntoStructures.elementAt(networkStructureInd).elementAt(commonBiomoietyInd))).elementAt(locationInd)));				r = ((Vector) (r.elementAt(rInd)));				s = ((Vector) (s.elementAt(rInd)));				linearPathsBetweenRootAndCommonBiomoieties.lastElement().lastElement().add(((Vector) (r.elementAt(0))));				linearPathsBetweenRootAndCommonBiomoietyPointLocations.lastElement().lastElement().add(((Vector) (s.elementAt(0))));				pathString = pathString + ((String[]) (((Vector) (r.elementAt(0))).elementAt(0)))[0];				commonBiomoietyInd++;			}			networkStructureInd++;		}		System.out.println("");		if (primaryOrSecondaryNetworks.equals("primary networks")) {			primaryNetworksLinearPathsFromRootToCommonBiomoieties = linearPathsBetweenRootAndCommonBiomoieties;			primaryNetworksLinearPointLocations = linearPathsBetweenRootAndCommonBiomoietyPointLocations;		} else {			secondaryNetworksLinearPathsFromRootToCommonBiomoieties = linearPathsBetweenRootAndCommonBiomoieties;			secondaryNetworksLinearPointLocations = linearPathsBetweenRootAndCommonBiomoietyPointLocations;		}	}	public static void printLocations(Vector vector, String callingObjectStructure, Vector<Integer> location) {		int ind = 0;		if (vector instanceof Vector) {			while (ind < vector.size()) {				if (vector.elementAt(ind) instanceof Point) {					System.out.println(callingObjectStructure + ".e(" + ind + ")[0]: " + ((Point) (vector.elementAt(ind))));				} else if (vector.elementAt(ind) instanceof Vector) {					location.add(ind);					printLocations((Vector) (vector.elementAt(ind)), callingObjectStructure + ".e(" + ind + ")", location);					location.remove(location.size() - 1);				} else if (vector.elementAt(ind) == null) {					System.out.println(callingObjectStructure + ".e(" + ind + ") = null");				} else {					System.out.println(callingObjectStructure + ".e(" + ind + ") != Point, Vector, or null");				}				ind++;			}		}	}	static Object[] getFullNetworkPaths(String primaryOrSecondaryNetworks) {		Object[] returnObject = new Object[2];		Vector<Vector<Vector<String[]>>> combinedPaths = new Vector<Vector<Vector<String[]>>>();		Vector<Vector<Vector<Point>>> pointLocationsAtEndsOfCombinedPaths = new Vector<Vector<Vector<Point>>>();		Vector<Vector<Vector<Vector<String[]>>>> linearPathFromRoot;		Vector<Vector<Vector<Vector<Point>>>> pointLocations;		if (primaryOrSecondaryNetworks.equals("primary networks")) {			linearPathFromRoot = primaryNetworksLinearPathsFromRootToCommonBiomoieties;			pointLocations = primaryNetworksLinearPointLocations;		} else {			linearPathFromRoot = secondaryNetworksLinearPathsFromRootToCommonBiomoieties;			pointLocations = secondaryNetworksLinearPointLocations;		}		int lastSimilarPathBiomoietyInd;		int linearPathFromRootSize = linearPathFromRoot.size();		int biomoietyNetworkInd = 0;		int pathInd1;		int pathInd2;		int biomoietyInd;		int ind4;		while (biomoietyNetworkInd < linearPathFromRoot.size()) {			pathInd1 = 0;			while (pathInd1 < linearPathFromRoot.elementAt(biomoietyNetworkInd).size()) {				pathInd2 = pathInd1 + 1;				while (pathInd2 < linearPathFromRoot.elementAt(biomoietyNetworkInd).size()) {					biomoietyInd = 0;					lastSimilarPathBiomoietyInd = -1;					while (lastSimilarPathBiomoietyInd == -1 && biomoietyInd < ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).size() && biomoietyInd < ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).size()) {						if (!((String[]) (((Vector) (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).elementAt(biomoietyInd))).elementAt(0)))[2].equals(((String[]) (((Vector) (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).elementAt(biomoietyInd))).elementAt(0)))[2])) {							lastSimilarPathBiomoietyInd = biomoietyInd;						}						biomoietyInd++;					}					combinedPaths.add(new Vector<Vector<String[]>>());					pointLocationsAtEndsOfCombinedPaths.add(new Vector<Vector<Point>>());					if (lastSimilarPathBiomoietyInd != -1) {						int pathInd = ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).size() - 1;						while (pathInd >= lastSimilarPathBiomoietyInd - 1) {							combinedPaths.lastElement().add(((Vector) (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).elementAt(pathInd))));							pointLocationsAtEndsOfCombinedPaths.lastElement().add(((Vector) (((Vector) (pointLocations.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).elementAt(pathInd))));							pathInd--;						}						pathInd = lastSimilarPathBiomoietyInd;						while (pathInd < ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).size()) {							combinedPaths.lastElement().add(((Vector) (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).elementAt(pathInd))));							pointLocationsAtEndsOfCombinedPaths.lastElement().add(((Vector) (((Vector) (pointLocations.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).elementAt(pathInd))));							pathInd++;						}					} else {						if (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).size() < ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).size()) {							int startPathInd = ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).size() - 1;							while (startPathInd < ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).size()) {								combinedPaths.lastElement().add(((Vector) (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).elementAt(startPathInd))));								pointLocationsAtEndsOfCombinedPaths.lastElement().add(((Vector) (((Vector) (pointLocations.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).elementAt(startPathInd))));								startPathInd++;							}						} else {							int startPathInd = ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd2))).size() - 1;							while (startPathInd < ((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).size()) {								combinedPaths.lastElement().add(((Vector) (((Vector) (linearPathFromRoot.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).elementAt(startPathInd))));								pointLocationsAtEndsOfCombinedPaths.lastElement().add(((Vector) (((Vector) (pointLocations.elementAt(biomoietyNetworkInd).elementAt(pathInd1))).elementAt(startPathInd))));								startPathInd++;							}						}					}					pathInd2++;				}				pathInd1++;			}			biomoietyNetworkInd++;		}		returnObject[0] = combinedPaths;		returnObject[1] = pointLocationsAtEndsOfCombinedPaths;		return returnObject;	}	static void printLinears(Vector<Vector<Vector<Vector<String[]>>>> linear) {		int ind0 = 0;		int ind1 = 0;		int ind2 = 0;		while (ind0 < linear.size()) {			ind1 = 0;			while (ind1 < linear.elementAt(ind0).size()) {				ind2 = 0;				System.out.print("linear.elementAt(" + ind0 + ").elementAt(" + ind1 + "): ");				while (ind2 < ((Vector) (((Vector) (linear.elementAt(ind0))).elementAt(ind1))).size()) {					System.out.print(((String[]) (((Vector) (((Vector) (((Vector) (linear.elementAt(ind0))).elementAt(ind1))).elementAt(ind2))).elementAt(0)))[0] + ", ");					System.out.print(((String[]) (((Vector) (((Vector) (((Vector) (linear.elementAt(ind0))).elementAt(ind1))).elementAt(ind2))).elementAt(0)))[0] + ", ");					ind2++;				}				System.out.println("");				ind1++;			}			ind0++;		}		System.out.println("");	}	private static Vector copyComplexStringArrayVector(Vector vector) {		Vector vectorCopy = new Vector();		int ind = 0;		while (ind < vector.size()) {			if (vector.elementAt(ind) instanceof Vector) {				vectorCopy.add(copyComplexStringArrayVector((Vector) (vector.elementAt(ind))));			} else {				vectorCopy.add(((String[]) (vector.elementAt(ind))));			}			ind++;		}		return vectorCopy;	}	private static void addNewBiomoietyPairAsNewRootFan(String[] biomoiety1, String[] biomoiety2) {		biomoietyGridLoci.add(new Vector(2, 1));		((Vector) (biomoietyGridLoci.lastElement())).add(new Vector(2, 1));		((Vector) (((Vector) (biomoietyGridLoci.lastElement())).lastElement())).add(biomoiety1);		((Vector) (biomoietyGridLoci.lastElement())).add(new Vector(2, 2));		((Vector) ((Vector) (biomoietyGridLoci.lastElement())).elementAt(1)).add(new Vector(2, 1));		((Vector) (((Vector) ((Vector) (biomoietyGridLoci.lastElement())).elementAt(1)).elementAt(0))).add(new Vector(2, 1));		((Vector) (((Vector) (((Vector) ((Vector) (biomoietyGridLoci.lastElement())).elementAt(1)).elementAt(0))).elementAt(0))).add(biomoiety2);		((Vector) (((Vector) ((Vector) (biomoietyGridLoci.lastElement())).elementAt(1)).elementAt(0))).add(new Vector(2, 2));		String rootBeingAdded = biomoiety1[2];		String nodeBeingAdded = biomoiety2[2];		String nodeAsAdded = ((String[]) (((Vector) (((Vector) (((Vector) ((Vector) (biomoietyGridLoci.lastElement())).elementAt(1)).elementAt(0))).elementAt(0))).elementAt(0)))[2];		String rootAsAdded = ((String[]) (((Vector) (((Vector) (biomoietyGridLoci.lastElement())).elementAt(0))).elementAt(0)))[2];	}	private static void addNewBiomoietyPairToExistingRootFan(String[] rootBiomoiety, String[] nodalBiomoiety, Vector<Integer> locationInStructure) {		boolean biomoiety2HUGOIDNodeFound = false;		Vector r = biomoietyGridLoci;		int ind = 0;		while (ind < locationInStructure.size() - 1) {			r = ((Vector) (r.elementAt(locationInStructure.elementAt(ind))));			ind++;		}		String[] biomoietyInStructure = ((String[]) (((Vector) (r.elementAt(0))).elementAt(0)));		if (!(biomoietyInStructure[8] + biomoietyInStructure[3]).equals(rootBiomoiety[8] + rootBiomoiety[3])) {			((Vector) (r.elementAt(0))).add(rootBiomoiety);		}		int nodeInd = 0;		while (!biomoiety2HUGOIDNodeFound && nodeInd < ((Vector) (r.elementAt(1))).size()) {			biomoiety2HUGOIDNodeFound = ((String[]) (((Vector) ((Vector) (((Vector) (r.elementAt(1))).elementAt(nodeInd))).elementAt(0))).elementAt(0))[2].equals(nodalBiomoiety[2]);			nodeInd++;		}		nodeInd = nodeInd - 1;		if (biomoiety2HUGOIDNodeFound) {			String g = ((String[]) (((Vector) ((Vector) (((Vector) (r.elementAt(1))).elementAt(nodeInd))).elementAt(0))).elementAt(0))[8] + ((String[]) (((Vector) ((Vector) (((Vector) (r.elementAt(1))).elementAt(nodeInd))).elementAt(0))).elementAt(0))[3];			if (!(g).equals(nodalBiomoiety[8] + nodalBiomoiety[3])) {				((Vector) (((Vector) ((Vector) (r.elementAt(1))).elementAt(nodeInd))).elementAt(0)).add(nodalBiomoiety);			}		} else {			((Vector) r.elementAt(1)).add(new Vector(2, 1));			((Vector) (((Vector) r.elementAt(1)).lastElement())).add(new Vector());			((Vector) (((Vector) (((Vector) r.elementAt(1)).lastElement())).lastElement())).add(nodalBiomoiety);			((Vector) (((Vector) r.elementAt(1)).lastElement())).add(new Vector(2, 2));		}	}	public static void printV(Vector v, String vectorID, int[] nodeLocation, int level) {		int ind = 0;		while (ind < v.size()) {			int lInd = 0;			while (lInd <= level) {				lInd++;			}			if (!((Vector) (((Vector) (v.elementAt(ind))).elementAt(1))).isEmpty()) {				level++;				nodeLocation[level] = ind;				printV(((Vector) (((Vector) (v.elementAt(ind))).elementAt(1))), vectorID + ".elementAt(" + String.valueOf(ind) + ").elementAt(1)", nodeLocation, level);			} else {			}			ind++;			nodeLocation[level] = ind;		}		nodeLocation[level] = 0;		level--;		if (level == -1) {			level = 0;		}	}	public static String parseQuery(String query) {		Vector<String> secondaryNetworksQueryTerms = new Vector<String>();		String parsedQuery = "";		int ind = 0;		if (calculateSecondaryNetworks) {			while (ind < primaryNetworksBiomoietyPairs.size()) {				if (!secondaryNetworksQueryTerms.contains(primaryNetworksBiomoietyPairs.elementAt(ind).elementAt(0).elementAt(0)[0])) {					secondaryNetworksQueryTerms.add(primaryNetworksBiomoietyPairs.elementAt(ind).elementAt(0).elementAt(0)[0].replace(" ", "&nbsp"));				}				if (!secondaryNetworksQueryTerms.contains(primaryNetworksBiomoietyPairs.elementAt(ind).elementAt(1).elementAt(0)[0])) {					secondaryNetworksQueryTerms.add(primaryNetworksBiomoietyPairs.elementAt(ind).elementAt(1).elementAt(0)[0].replace(" ", "&nbsp"));				}				ind++;			}			ind = 1;			if (!secondaryNetworksQueryTerms.isEmpty()) {				parsedQuery = secondaryNetworksQueryTerms.elementAt(0) + "[MH]";			} else {				return "NO_QUERY_TERMS_FOUND";			}			while (ind < secondaryNetworksQueryTerms.size()) {				parsedQuery = parsedQuery + "+OR+" + secondaryNetworksQueryTerms.elementAt(ind) + "[MH]";				ind++;			}		} else {			parsedQuery = query;			Pattern pattern = Pattern.compile("\n");			Matcher matcher = pattern.matcher(parsedQuery);			parsedQuery = matcher.replaceAll("+OR+");			parsedQuery.toUpperCase().replace(" OR ", "+OR+").replace(" AND ", "+AND+");			parsedQuery.replace(" ", "&nbsp").replace("\"", "&quot");		}		parsedQuery = parsedQuery.replace(" ", "+");		System.out.println("d parsedQuery: " + parsedQuery);		return parsedQuery;	}	public static BufferedReader createNLMFileConnectionBufferedReader(String pQuery) {		SystemWindow.println("pQuery: " + pQuery);		String webEnv = "nulled";		String queryKey = "nulled";		String webEnvAndQueryKeyIndiceContentPageURLString = "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=" + pQuery + "&usehistory=y";		String abstractsContentPageURLString = "http://www.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&rettype=medline&retmax=1000&tool=VitalityEHR&email=crawfodo@yahoo.com";		boolean stop = false;		boolean onLastToken = false;		int ind = 0;		URLConnection connection = null;		try {			if (overRidePubMedRetrievalWithLocalFiles) {				connection = new File(Device.device.binDir + "MolecularAssemblerFiles/esearch.fcgi").toURI().toURL().openConnection();				System.out.println("Connection established.");			} else {				URL url = new URL(webEnvAndQueryKeyIndiceContentPageURLString);				connection = url.openConnection();				System.out.println("Connection not established.");			}		} catch (Exception ex) {			ex.printStackTrace();			SystemWindow.println("url1 setting failure: ");		}		BufferedReader in = null;		try {			in = new BufferedReader(new InputStreamReader(connection.getInputStream()));			boolean queryKeyFound = false;			int inde = 0;			while (inde < 20 && !queryKeyFound && queryKey != null) {				if ((queryKey = in.readLine()).indexOf("<QueryKey>") != -1) {					webEnv = queryKey.toString();					SystemWindow.println("queryKey as readLine(): " + queryKey);					queryKey = queryKey.substring(queryKey.indexOf("<QueryKey>") + 10, queryKey.indexOf("</QueryKey>"));					queryKeyFound = true;					SystemWindow.println("queryKeyFound");				} else {					SystemWindow.println("!queryKeyFound");				}				inde++;			}			boolean webEnvFound = false;			int inder = 0;			while (inder < 20 && !webEnvFound && queryKey != null) {				if (webEnv.indexOf("<WebEnv>") != -1) {					webEnv = webEnv.substring(webEnv.indexOf("<WebEnv>") + 8, webEnv.indexOf("</WebEnv>"));					Device.device.workspace.decisionSupportWindow.addTalkbackText("Negotiating with the NLM", null, true);					SystemWindow.println("webEnv now: " + webEnv);					webEnvFound = true;					SystemWindow.println("webEnvFound");				} else {					webEnv = in.readLine();					SystemWindow.println("!webEnvFound");				}				inder++;			}		} catch (IOException ed) {			SystemWindow.println("WebEnv return failed in DS; WebEnv should have been in XML tag of same name in content of URL: " + webEnvAndQueryKeyIndiceContentPageURLString);			ed.printStackTrace();		}		try {			in.close();		} catch (IOException ex) {			SystemWindow.println("Failed getting webEnv and queryString. in = null when pubmed returns an error");		}		URLConnection connection2 = null;		SystemWindow.println("webEnv: " + webEnv);		SystemWindow.println("queryKey: " + queryKey);		queryKey = "001";		abstractsContentPageURLString = abstractsContentPageURLString + "&query_key=" + queryKey + "&WebEnv=" + webEnv;		SystemWindow.println("EFetch URL: " + abstractsContentPageURLString);		try {			if (overRidePubMedRetrievalWithLocalFiles) {				if (!calculateSecondaryNetworks) {					connection2 = new File(Device.device.binDir + "MolecularAssemblerFiles/efetch.fcgi2.html").toURI().toURL().openConnection();				} else {					SystemWindow.println("connection2 hit");					connection2 = new File(Device.device.binDir + "MolecularAssemblerFiles/2.htm").toURI().toURL().openConnection();				}			} else {				URL url2 = new URL(abstractsContentPageURLString);				connection2 = url2.openConnection();				SystemWindow.println("Made a connection to pubmed.");			}		} catch (Exception ex) {			SystemWindow.println("Failed to make a connection to pubmed.");		}		BufferedReader in2 = null;		try {			in2 = new BufferedReader(new InputStreamReader(connection2.getInputStream()));			SystemWindow.println("Made a BufferedReader to NLM.");		} catch (IOException ex) {			SystemWindow.println("Failed to make a BufferedReader to NLM.");		}		return in2;	}	public static void printB(Vector vector, String callingObjectStructure, Vector<Integer> location) {		int ind = 0;		while (ind < vector.size()) {			if (vector.elementAt(ind) instanceof String[]) {				System.out.println(callingObjectStructure + ".e(" + ind + ")[0]: " + ((String[]) (vector.elementAt(ind)))[0]);			} else if (vector.elementAt(ind) instanceof Vector) {				location.add(ind);				printB((Vector) (vector.elementAt(ind)), callingObjectStructure + ".e(" + ind + ")", location);				location.remove(location.size() - 1);			} else if (vector.elementAt(ind) == null) {				System.out.println(callingObjectStructure + ".e(" + ind + ") = null");			} else {				System.out.println(callingObjectStructure + ".e(" + ind + ") != String[], Vector, or null");			}			ind++;		}	}	public static void calculateSecondaryNetworksPaths(Object[] primaryNetworksPathsAndPointLocations, Object[] secondaryNetworksPathsAndPointLocations) {		primaryNetworksPaths = (Vector<Vector<Vector<String[]>>>) (primaryNetworksPathsAndPointLocations[0]);		primaryNetworksPointLocations = (Vector<Vector<Vector<Point>>>) (primaryNetworksPathsAndPointLocations[1]);		secondaryNetworksPaths = (Vector<Vector<Vector<String[]>>>) (secondaryNetworksPathsAndPointLocations[0]);		double distanceBetweenPrimaryNetworksEndPoints;		int numSecondaryNetworksPolylineSegments;		int primaryNetworksInd1 = 0;		int primaryNetworksLastInd;		int secondaryNetworksInd1;		int secondaryNetworksLastInd;		int secondaryNetworksPathsSize = secondaryNetworksPaths.size();		System.out.println("TraM.referencePublications.size(): " + MolecularAssembler.referencePublications.size());		while (primaryNetworksInd1 < primaryNetworksPaths.size()) {			primaryNetworksLastInd = primaryNetworksPaths.elementAt(primaryNetworksInd1).size() - 1;			secondaryNetworksInd1 = 0;			while (secondaryNetworksInd1 < secondaryNetworksPathsSize) {				boolean secondaryNetworksPathContainsATrial = false;				int ind = 0;				while (ind < secondaryNetworksPaths.elementAt(secondaryNetworksInd1).size()) {					int nodalBiomoietyArticleInd = Integer.valueOf((((String[]) (((Vector) (secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(ind))).elementAt(0))))[8]);					if (MolecularAssembler.referencePublications.elementAt(nodalBiomoietyArticleInd)[9] != null && MolecularAssembler.referencePublications.elementAt(nodalBiomoietyArticleInd)[9].toLowerCase().contains(" trial")) {						secondaryNetworksPathContainsATrial = true;					} else {					}					ind++;				}				secondaryNetworksLastInd = secondaryNetworksPaths.elementAt(secondaryNetworksInd1).size() - 1;				if (!Device.device.workspace.decisionSupportWindow.tertiaryNetworksMustContainATrial || secondaryNetworksPathContainsATrial) {					if (primaryNetworksInd1 != secondaryNetworksInd1 && primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(0).elementAt(0)[2]) && primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(secondaryNetworksLastInd).elementAt(0)[2]) || primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(secondaryNetworksLastInd).elementAt(0)[2]) && primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(0).elementAt(0)[2])) {						if (secondaryNetworksPaths.elementAt(secondaryNetworksInd1).size() > 2) {							numSecondaryNetworksPolylineSegments = secondaryNetworksPaths.elementAt(secondaryNetworksInd1).size() - 1;							distanceBetweenPrimaryNetworksEndPoints = Math.sqrt((primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y) * (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y) + (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x) * (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x));							Point[] returnPoint = new Point[2];							if (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x < primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x) {								returnPoint[0] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0);								returnPoint[1] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0);							} else if (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x > primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x) {								returnPoint[0] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0);								returnPoint[1] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0);							} else if (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y > primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y) {								returnPoint[0] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0);								returnPoint[1] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0);							} else {								System.out.println("this shouldn't exist programmatically since the first biomoiety location should always be to the left");								returnPoint[0] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0);								returnPoint[1] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0);							}							tertiaryNetworks.add(secondaryNetworksPaths.elementAt(secondaryNetworksInd1));							primaryNetworksDistancesBetweenEndPoints.add(distanceBetweenPrimaryNetworksEndPoints);							primaryNetworksEndPoints.add(returnPoint);						}					} else if (primaryNetworksInd1 != secondaryNetworksInd1 && (primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(0).elementAt(0)[2]) || primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(secondaryNetworksLastInd).elementAt(0)[2]))) {						numSecondaryNetworksPolylineSegments = secondaryNetworksPaths.elementAt(secondaryNetworksInd1).size() - 1;						distanceBetweenPrimaryNetworksEndPoints = Math.sqrt((primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y) * (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y) + (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x) * (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x));						Point[] returnPoint = new Point[2];						returnPoint[0] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0);						returnPoint[1] = null;						tertiaryNetworks.add(secondaryNetworksPaths.elementAt(secondaryNetworksInd1));						primaryNetworksDistancesBetweenEndPoints.add(distanceBetweenPrimaryNetworksEndPoints);						primaryNetworksEndPoints.add(returnPoint);					} else if (primaryNetworksInd1 != secondaryNetworksInd1 && (primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(0).elementAt(0)[2]) || primaryNetworksPaths.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0)[2].equals(secondaryNetworksPaths.elementAt(secondaryNetworksInd1).elementAt(secondaryNetworksLastInd).elementAt(0)[2]))) {						numSecondaryNetworksPolylineSegments = secondaryNetworksPaths.elementAt(secondaryNetworksInd1).size() - 1;						distanceBetweenPrimaryNetworksEndPoints = Math.sqrt((primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y) * (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).y - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).y) + (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x) * (primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0).x - primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(0).elementAt(0).x));						Point[] returnPoint = new Point[2];						returnPoint[0] = primaryNetworksPointLocations.elementAt(primaryNetworksInd1).elementAt(primaryNetworksLastInd).elementAt(0);						returnPoint[1] = null;						tertiaryNetworks.add(secondaryNetworksPaths.elementAt(secondaryNetworksInd1));						primaryNetworksDistancesBetweenEndPoints.add(distanceBetweenPrimaryNetworksEndPoints);						primaryNetworksEndPoints.add(returnPoint);					} else if (primaryNetworksInd1 == secondaryNetworksInd1) {						System.out.println("Check if can remove primaryNetworksInd1 != secondaryNetworksInd1 clause");					}				}				secondaryNetworksInd1++;			}			primaryNetworksInd1++;		}		System.out.println("Ok, stopped");	}	public static void printCombined(Object[] pathsObject) {		System.out.println("");		System.out.println("");		Vector<Vector<Vector<String[]>>> pathsBetweenCommonBiomoieties = (Vector<Vector<Vector<String[]>>>) (pathsObject[0]);		Vector<Vector<Vector<Point>>> pathsBetweenCommonBiomoietiesPointLocations = (Vector<Vector<Vector<Point>>>) (pathsObject[1]);		int ind0 = 0;		int ind1 = 0;		while (ind0 < pathsBetweenCommonBiomoieties.size()) {			ind1 = 0;			System.out.print("pathsBetweenCommonBiomoieties.elementAt(" + ind0 + ").elementAt(" + ind1 + "): ");			while (ind1 < ((Vector) (pathsBetweenCommonBiomoieties.elementAt(ind0))).size()) {				System.out.print(((String[]) (((Vector) (((Vector) (pathsBetweenCommonBiomoieties.elementAt(ind0))).elementAt(ind1))).elementAt(0)))[0] + ", ");				ind1++;			}			ind1 = 0;			System.out.println("");			System.out.println("");			System.out.print("pathsBetweenCommonBiomoietiesPointLocations.elementAt(" + ind0 + ").elementAt(" + ind1 + "): ");			while (ind1 < ((Vector) (pathsBetweenCommonBiomoieties.elementAt(ind0))).size()) {				System.out.print(((Point) (((Vector) (((Vector) (pathsBetweenCommonBiomoietiesPointLocations.elementAt(ind0))).elementAt(ind1))).elementAt(0))) + ", ");				ind1++;			}			System.out.println("");			ind0++;		}		System.out.println("");	}	public static void calculateIntersectingTertiaryNetworksGraphicPrimitives() {		tertiaryNetworksPolyLinePointsX = new Vector<int[]>();		tertiaryNetworksPolyLinePointsY = new Vector<int[]>();		tertiaryNetworks = new Vector<Vector<Vector<String[]>>>();		primaryNetworksDistancesBetweenEndPoints = new Vector<Double>();		primaryNetworksEndPoints = new Vector<Point[]>();		tertiaryNetworksPolyLinePointsX.add(null);		tertiaryNetworksPolyLinePointsY.add(null);		tertiaryNetworks.add(null);		primaryNetworksDistancesBetweenEndPoints.add(null);		primaryNetworksEndPoints.add(null);		primaryNetworksCommonBiomoietyIndiceLocations = MolecularAssembler.fillCommonBiomoietyLocationVector(MolecularAssembler.primaryNetworksBiomoietyGridLoci, MolecularAssembler.secondaryNetworksBiomoietyGridLoci, new Vector<Vector<Integer>>(), new Vector<Integer>());		secondaryNetworksCommonBiomoietyIndiceLocations = MolecularAssembler.fillCommonBiomoietyLocationVector(MolecularAssembler.secondaryNetworksBiomoietyGridLoci, MolecularAssembler.primaryNetworksBiomoietyGridLoci, new Vector<Vector<Integer>>(), new Vector<Integer>());		createLinearPathsBetweenRootAndCommonBiomoieties(MolecularAssembler.primaryNetworksCommonBiomoietyIndiceLocations, "primary networks");		createLinearPathsBetweenRootAndCommonBiomoieties(MolecularAssembler.secondaryNetworksCommonBiomoietyIndiceLocations, "secondary networks");		calculateSecondaryNetworksPaths(MolecularAssembler.getFullNetworkPaths("primary networks"), MolecularAssembler.getFullNetworkPaths("secondary networks"));		if (!Device.device.workspace.decisionSupportWindow.parsedQuery.equals("NO_QUERY_TERMS_FOUND") && !Device.device.workspace.decisionSupportWindow.cycleTherapeuticTargetsParameterString.equals("NONE")) {			int secondaryNetworksInd = 1;			boolean stop = false;			while (!stop && secondaryNetworksInd < tertiaryNetworks.size()) {				if (primaryNetworksEndPoints.elementAt(secondaryNetworksInd)[1] != null) {					calculateTertiaryNetworksPathPoints(secondaryNetworksInd, "looped");				} else if (Device.device.workspace.decisionSupportWindow.includeTertiaryNetworksNotLoopingBackOntoPrimaryNetworks) {					calculateTertiaryNetworksPathPoints(secondaryNetworksInd, "unlooped");				}				secondaryNetworksInd++;			}		}	}	public static void calculateTertiaryNetworksPathPoints(int pSecondaryNetworksInd, String loopedOrUnlooped) {		double segmentLength;		segmentLength = Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.coOcurreLineLength;		int pathSize = MolecularAssembler.tertiaryNetworks.elementAt(pSecondaryNetworksInd).size();		int positionY;		int positionX;		int yLast;		int xLast;		double initialPolylineSegmentAngle;		int ind2 = 0;		MolecularAssembler.tertiaryNetworksPolyLinePointsX.add(new int[pathSize]);		MolecularAssembler.tertiaryNetworksPolyLinePointsY.add(new int[pathSize]);		while ((pathSize - 1) * segmentLength < 1.1 * MolecularAssembler.primaryNetworksDistancesBetweenEndPoints.elementAt(pSecondaryNetworksInd)) {			segmentLength = 1.1 * segmentLength;		}		double[] polygonSegmentToSegmentAndEndpointsAnglesDouble = MolecularAssembler.polygonSegmentToSegmentAndEndpointAngles(pathSize, segmentLength, MolecularAssembler.primaryNetworksDistancesBetweenEndPoints.elementAt(pSecondaryNetworksInd), pSecondaryNetworksInd);		double primaryNetworksAngle = 0;		double secondaryNetworksAngle;		if (loopedOrUnlooped.equals("looped")) {			primaryNetworksAngle = Math.atan(((double) MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[0].y - (double) MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[1].y) / ((double) MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[1].x - (double) MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[0].x));			secondaryNetworksAngle = polygonSegmentToSegmentAndEndpointsAnglesDouble[1];		} else {			secondaryNetworksAngle = Math.PI / 3;		}		initialPolylineSegmentAngle = polygonSegmentToSegmentAndEndpointsAnglesDouble[0];		double polylineSegmentAngle = initialPolylineSegmentAngle - secondaryNetworksAngle + primaryNetworksAngle;		positionY = MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[0].y;		positionX = MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[0].x;		if (loopedOrUnlooped.equals("looped")) {			yLast = MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[1].y;			xLast = MolecularAssembler.primaryNetworksEndPoints.elementAt(pSecondaryNetworksInd)[1].x;			ind2 = 0;			while (ind2 < pathSize - 1) {				MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind2] = positionX;				MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind2] = positionY;				positionY = (int) (positionY - segmentLength * Math.sin(polylineSegmentAngle));				positionX = (int) (positionX + segmentLength * Math.cos(polylineSegmentAngle));				polylineSegmentAngle = polylineSegmentAngle + initialPolylineSegmentAngle;				ind2++;			}			MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind2] = xLast;			MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind2] = yLast;			Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.createTertiaryNetworkPathButtons(MolecularAssembler.tertiaryNetworksPolyLinePointsX.size() - 1, "looped");		} else {			int nextY = (int) Math.sqrt((Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.coOcurreLineLength * Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.coOcurreLineLength) / 2);			int nextX = nextY;			ind2 = 0;			while (ind2 < pathSize) {				MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind2] = positionX;				MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind2] = positionY;				positionY = (int) (positionY + nextY);				nextY = -nextY;				positionX = (int) (positionX + nextX);				ind2++;			}			Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.createTertiaryNetworkPathButtons(MolecularAssembler.tertiaryNetworksPolyLinePointsX.size() - 1, "unlooped");			int ind = 0;			while (ind < MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement().length) {				if (Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.leftmostTertiaryNetworksPixelX > MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind]) {					Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.leftmostTertiaryNetworksPixelX = MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind];				} else if (Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.rightmostTertiaryNetworksPixelX < MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind]) {					Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.rightmostTertiaryNetworksPixelX = MolecularAssembler.tertiaryNetworksPolyLinePointsX.lastElement()[ind];				}				if (Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.topmostTertiaryNetworksPixelY > MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind]) {					Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.topmostTertiaryNetworksPixelY = MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind];				} else if (Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.topmostTertiaryNetworksPixelY < MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind]) {					Device.device.workspace.decisionSupportWindow.molecularNetworksPanel.topmostTertiaryNetworksPixelY = MolecularAssembler.tertiaryNetworksPolyLinePointsY.lastElement()[ind];				}				ind++;			}		}	}	public static double[] polygonSegmentToSegmentAndEndpointAngles(double pathSize, double segmentLength, double distBetweenPrimaryNetworksPoints, int returnPathInd) {		double[] returnAngle = new double[2];		double angleBetweenEndpoints = 0;		double polylineSegmentAngle = 0;		double increasingPolylineSegmentAngle = 2 * Math.PI / (pathSize - 1);		double distBetweenTertiaryNetworksPoints = 0;		double increment = 0.001;		int ind;		double y = 0;		double x = 0;		double fY = 0;		double fX = 0;		while (distBetweenTertiaryNetworksPoints < distBetweenPrimaryNetworksPoints) {			polylineSegmentAngle = increasingPolylineSegmentAngle;			fY = y;			fX = x;			y = 0;			x = 0;			ind = 0;			while (ind < pathSize - 1) {				y = y + segmentLength * Math.sin(polylineSegmentAngle);				x = x + segmentLength * Math.cos(polylineSegmentAngle);				polylineSegmentAngle = polylineSegmentAngle + increasingPolylineSegmentAngle;				ind++;			}			increasingPolylineSegmentAngle = increasingPolylineSegmentAngle - increment;			distBetweenTertiaryNetworksPoints = Math.sqrt(y * y + x * x);		}		increasingPolylineSegmentAngle = increasingPolylineSegmentAngle + increment;		distBetweenTertiaryNetworksPoints = Math.sqrt(fY * fY + fX * fX);		if (fX == 0) {			angleBetweenEndpoints = Math.PI / 2;		} else if (fX < 0 && (fY < 0 || fY > 0)) {			angleBetweenEndpoints = Math.atan(fY / fX) + Math.PI;		} else {			angleBetweenEndpoints = Math.atan(fY / fX);		}		returnAngle[0] = increasingPolylineSegmentAngle;		returnAngle[1] = angleBetweenEndpoints;		return returnAngle;	}}// EOF